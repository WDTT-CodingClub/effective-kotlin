## 코틀린에서 코드 동작에 제한을 걸 때 방법

- require : 아규먼트 제한
- check : 상태와 관련된 동작 제한
- asset : 어떤 것이 true인지 확인, 테스트모드에서만 작동
- return 또는 Throw와 함께 활용하는 Elvis 연산자

### 제한을 걸때 장점

- 문서를 읽지 않은 개발자도 문제 확인 가능
- 문제가 있을 경우 함수가 예상하지 못한 동작을 하지 않고 예외를 throw함
- 코드가 어느 정도 자체적으로 검사되어 단위 테스트 줄일 수 있음
- 스마트 캐스트 기능 활용 가능

## 아규먼트

함수 정의할 때 타입 시스템을 활용하여 아규먼트에 제한을 거는 코드를 많이 사용함

이러한 제한을 걸 때는 require 함수를 사용한다.
제한을 확인하고 제한을 만족하지 못할 경우 예외를 throw한다.

## 상태

구체적인 조건을 만족할 때만 함수를 사용할 수 있게 해야 할 때가 있다.

상태와 관련된 제한을 걸때는 일반적으로 check 함수를 사용한다.

> require vs check
> 
>둘은 사용 목적이 다름
>
>require
>
>목적: 주로 함수의 파라미터가 유효한지를 검사할 때 사용.
>
>조건: 조건이 false일 경우 IllegalArgumentException을 발생시킵니다.
>
>사용 예시:
>
>```kotlin
>fun setAge(age: Int) {
>    require(age >= 0) { "Age must be non-negative" }
>    // 함수의 나머지 코드
>}
>```
>사용처: 일반적으로 함수나 클래스의 인스턴스 생성 시 유효성 검사를 할 때 유용합니다. 예를 들어, 사용자가 입력한 값이 올바른 형식인지 확인하는 경우에 사용합니다.
>
>check
>목적: 주로 프로그램의 상태나 인스턴스의 유효성을 검사할 때 사용됩니다.
>
>조건: 조건이 false일 경우 IllegalStateException을 발생시킵니다.
>
>사용 예시:
>```kotlin
>fun performAction() {
>    check(isInitialized) { "Action cannot be performed before initialization" }
>    // 함수의 나머지 코드
>}
>```
>사용처: 보통 객체가 예상된 상태인지 확인하는 경우에 사용합니다. 예를 들어, 특정 기능을 수행하기 전에 객체가 초기화되었는지 확인할 때 유용합니다.

## Assert 계열 함수 사용

함수가 올바르게 구현되었다면, 확실하게 참을 낼 수 있는 코드들이 있다.
그런데 함수가 올바르게 구현되지 않을 수도 있다.

이런 구현 문제로 발생할 수 있는 추가적인 문제를 예방하려면 단위 테스트를 사용하는것이 좋다

```kotlin
class stackTest {

@Test
  fun `Stack pops correct number of elements`() {
    val stack = Stack(20) { it }
    val ret = stack.pop(10)
    assertEquals(10, ret.size)
  }

  fun pop(num: Int = 1): List<T> {
    //...
    assert(ret.size == num)
    return ret
  }
}
```

단위 테스트는 구현의 정확성을 확인하는 가장 기본적인 방법

이런 조건은 코틀린/JVM에서만 활성화 됨

- Assert 계열의 함수는 코드 를 자체 점검하며, 더 효율적으로 테스트 할 수 있게 해줌
- 특정 상황이 아닌 모든 상황에 대한 테스트를 할 수 있다
- 실행 시점에 정확하게 어떻게 되는지 확인할 수 있다.
- 실제 코드가  더 빠른 시점에 실패하게 만든다. 따라서 예상하지 못한 동작이 언제 어디서 실행되었는지 쉽게 찾을 수 있다.

파이썬에서 굉장히 많이 사용되는데, 자바에서는 딱히 사용되지않음.
코틀린에선 코드를 안정적으로 만들고 싶을 때 양념처럼 사용 할 수 있다는 것을 기억하자

## nullability와 스마트 캐스팅

코틀린에서 require와 check 블록으로 어떤 조건을 확인해서 true가 나왔다면, 해당 조건은 이후로도 true일 거라고 가정한다.

따라서 이를 활요ㅗㅇ해 타입 비교를 했다면, 스마트 캐스트가 작동함.

```kotlin
  fun checkNum(i: Int?): Int {
    requireNotNull(i)

    return i
}
```

### 정리
- 제한을 훨씬 더 쉽게 확인할 수 있다.
- 애플리케이션을 더 안정적으로 지킬 수 있다.
- 코드를 잘못 쓰는 상황을 막을 수 있다.
- 스마트 캐스팅을 활용할 수 있다.
